import { type InputCurrencyRangeProps } from '@commercelayer/app-elements/dist/ui/forms/InputCurrencyRange'
import type { RelationshipSelectorProps } from '@commercelayer/app-elements/dist/ui/resources/RelationshipSelector'

export const filtrableTimeRangePreset = [
  'today',
  'last7days',
  'last30days',
  'custom'
] as const

export type UiFilterName = string
export type UiFilterValue = string | string[] | boolean | Date | undefined

export type TimeRangePreset = (typeof filtrableTimeRangePreset)[number]

export interface TimeRangeFormValues {
  timePreset?: TimeRangePreset | null
  timeFrom?: Date | null
  timeTo?: Date | null
}

type CurrencyRangeSdkPredicate = string // example: 'total_amount_cents'
export interface CurrencyRangeFieldValue {
  from?: number | null
  to?: number | null
  currencyCode?: string | null
}
export type CurrencyRangeFormValues = Record<
  CurrencyRangeSdkPredicate,
  CurrencyRangeFieldValue
>

export interface PageInfoFormValues {
  viewTitle?: string
}

export type FormFullValues = Record<
  UiFilterName,
  UiFilterValue | CurrencyRangeFieldValue
> &
  TimeRangeFormValues &
  PageInfoFormValues

export interface BaseFilterItem {
  /**
   * Label of the filter field in form component
   */
  label: string
  /**
   * Flag to hide the filter field in form component
   */
  hidden?: boolean
  /**
   * Instruction to use this item to build the sdk query
   */
  sdk: {
    /**
     * SDK predicate to use in the query (example: `status_in` or `name_cont`)
     */
    predicate: string
    /**
     * Set the default options to use in the query when this filter is not selected.
     * Example, you have no `status_in` selected in UI, but if this option is `['placed', 'approved']`, the query will always contain
     * a `status_in` predicate with `placed` and `approved` statuses. This helps to avoid getting status we never want to see (eg: 'draft')
     */
    defaultOptions?: string[]
    /**
     * Custom function to transform the form value to the SDK value
     */
    parseFormValue?: (value: unknown) => string | number | boolean | undefined
  }
}

export type FilterItemOptions = BaseFilterItem & {
  type: 'options'
  render:
    | {
        /**
         * UI component to render
         */
        component: 'toggleButtons'
        /**
         * props required for the UI component
         */
        props: {
          mode: 'multi' | 'single'
          /**
           * an option can be hidden from the UI but still be used in the query
           * Example: we wont show the button to filter `pending` status in the UI, but we still want to accept it for a predefined list)
           */
          options: Array<{ label: string; value: string; isHidden?: boolean }>
        }
      }
    | {
        /**
         * UI component to render
         */
        component: 'relationshipSelector'
        /**
         * props required for the UI component
         */
        props: Omit<
          RelationshipSelectorProps,
          'onChange' | 'defaultValues' | 'title'
        >
      }
}

export interface FilterItemTextSearch extends Omit<BaseFilterItem, 'sdk'> {
  type: 'textSearch'
  render: {
    /**
     * UI component to render
     */
    component: 'searchBar'
  }
  sdk: Pick<BaseFilterItem['sdk'], 'predicate'>
}

export interface FilterItemTime extends Omit<BaseFilterItem, 'sdk'> {
  type: 'timeRange'
  sdk: {
    /**
     * SDK predicate to use in the query (example: `updated_at` or `updated_at`).
     * Don't use `_gteq` or `_lteq` suffixes, they will be generated by the filter method based on the following key
     * Example given the key `updated_at`, the generated predicate will be `updated_at_gteq` or `updated_at_lteq` depending on the preset
     */
    predicate: string
  }
  render: {
    component: 'dateRangePicker'
  }
}

export interface FilterItemCurrencyRange extends Omit<BaseFilterItem, 'sdk'> {
  type: 'currencyRange'
  sdk: {
    /**
     * SDK predicate to use in the query (example: `total_amount_cents` or `subtotal_amount_cents`).
     * Don't use `_gteq` or `_lteq` suffixes, they will be generated by the filter method based on the following key
     * Example given the key `total_amount_cents`, the generated predicate will be `total_amount_cents_gteq` or `total_amount_cents_lteq`
     * It will also add the `currency_code_eq` predicate
     */
    predicate: string
  }
  render: {
    component: 'inputCurrencyRange'
    props: Omit<
      InputCurrencyRangeProps,
      'onChange' | 'fromCents' | 'toCents' | 'defaultCurrency' | 'currencyList'
    >
  }
}

export type FiltersInstructionItem =
  | FilterItemOptions
  | FilterItemTextSearch
  | FilterItemTime
  | FilterItemCurrencyRange

export type FiltersInstructions = FiltersInstructionItem[]

export function isItemOptions(
  item: FiltersInstructionItem
): item is FilterItemOptions {
  return item.type === 'options'
}

export function isTextSearch(
  item: FiltersInstructionItem
): item is FilterItemTextSearch {
  return item.type === 'textSearch'
}

export function isCurrencyRange(
  item: FiltersInstructionItem
): item is FilterItemCurrencyRange {
  return item.type === 'currencyRange'
}
